{"version":3,"file":"Tensor.js","sourceRoot":"","sources":["../modules/Tensor.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  throwInvariant,\n  product,\n  deriveShape,\n  computeStrides,\n  flattenArray,\n  range,\n  slice1d,\n\n  Shape,\n  DeepArray\n} from './utils';\n\nimport Thunk from './Thunk';\n\nclass Tensor<T> {\n  readonly _array: Thunk<T[]>;\n  readonly _shape: Shape;\n  readonly _strides: Shape;\n\n  constructor(array: Tensor<T> | Thunk<T[]>, shape:Shape, strides?:Shape) {\n    if (array instanceof Tensor) {\n      this._array = array._array;\n    } else if (array instanceof Thunk) {\n      this._array = array;\n    } else {\n      throw Error(\"Invalid Input Backing Array\");\n    }\n    this._shape = shape;\n    this._strides = strides || computeStrides(shape);\n  }\n  tolist():DeepArray<T> {\n    return this._array\n      .map(a => reshape1d(a, this._strides, this._shape))\n      .valueOf();\n  }\n  toArray() {\n    return this.tolist();\n  }\n  flatten():Tensor<T> {\n    const thunk:Thunk<T[]> = this._array\n      .map(a => flatten(a, this._strides, this._shape));\n    const shape:Shape = [product(this._shape)];\n    return new Tensor(thunk, shape);\n  }\n  reshape(newShape:Shape):Tensor<T> {\n    return new Tensor(this._getArray(), newShape);\n  }\n  slice(start:Shape, size:Shape):Tensor<T> {\n    let istart = 0;\n    for (let i=0; i<start.length; i++) {\n      istart += start[i] * this._strides[i];\n    }\n    const thunk = this._array\n      .map(a => _flatten(a, istart, this._strides, size))\n    return new Tensor(thunk, size);\n  }\n  transpose(dims?:Shape):Tensor<T> {\n    if (!dims) {\n      dims = range(0, this._shape.length, 1);\n      dims.reverse();\n    }\n    throwInvariant(_checkTransposeDims(dims),\n        \"Invalid transpose dimensions\");\n    const newShape  = dims.map(d => this._shape[d]);\n    const newStrides = dims.map(d => this._strides[d]);\n    const newTensor = new Tensor(this, newShape, newStrides);\n    return newTensor;\n  }\n  reduceAlongAxis<U>(axis:number, func: (a:U, b:T)=>U, zero:U) {\n    const newShape = this._shape.filter((s, i) => i !== axis);\n    const axisLen = this._shape[axis];\n    const nSlices = product(this._shape) / axisLen;\n    const stride = this._strides[axis];\n    const step = this._strides[this._strides.length-1];\n    const thunk = this._array.map(a => {\n      let istart = 0;\n      let output:U[] = [];\n      for (let s=0; s<nSlices; s++) {\n        let index = istart;\n        let acc = zero;\n        let val:T;\n        for (let i=0; i<axisLen; i++) {\n          val = a[index];\n          acc = func(acc, val);\n          index = index + stride; \n        }\n        output.push(acc);\n        istart = istart + step;\n      }\n      return output;\n    });\n    return new Tensor(thunk, newShape);\n  }\n  _getArray():Thunk<T[]> {\n    if (this._isTransposed()) {\n      return this.flatten()._array;\n    } else {\n      return this._array;\n    }\n  }\n  _isTransposed():boolean {\n    let prev = Infinity;\n    for (let i=0; i<this._strides.length; i++) {\n      if (prev < this._strides[i]) {\n        return true;\n      }\n      prev = this._strides[i];\n    }\n    return false;\n  }\n}\n\nfunction flatten<T>(array:T[], strides:Shape, shape:Shape):T[] {\n  return _flatten(array, 0, strides, shape);\n}\n\nfunction _flatten<T>(array:T[], start:number, strides:Shape, shape:Shape):T[] {\n  if (shape.length === 1) {\n    return slice1d(array, start, shape[0], strides[0]);\n  }\n  const size = product(shape);\n  const [d, ...restShape] = shape;\n  const [stride, ...restStrides] = strides;\n  const newArray:T[][] = [];\n  for (let i=0; i<d; i++) {\n    newArray.push(\n      _flatten(array, start + i * stride, restStrides, restShape));\n  }\n  const empty: T[] = [];\n  return empty.concat(...newArray);\n}\n\nfunction reshape1d<T>(array:T[], strides:Shape, shape:Shape):DeepArray<T> {\n  throwInvariant(array.length === product(shape),\n      \"Invalid Shape while reshaping 1d array\");\n  if (!array.length) {\n    return [];\n  }\n  return _reshape1d(array, 0, strides, shape);\n}\nfunction _reshape1d<T>(array:T[], start:number, strides:Shape, shape:Shape):DeepArray<T> {\n  if (shape.length === 1) {\n    return slice1d(array, start, shape[0], strides[0]);\n  }\n  const size = product(shape);\n  const [d, ...restShape] = shape;\n  const [stride, ...restStrides] = strides;\n  const newArray:DeepArray<T> = [];\n  for (let i=0; i<d; i++) {\n    newArray.push(\n      _reshape1d(array, start + i * stride, restStrides, restShape));\n  }\n  return newArray;\n}\nfunction _checkTransposeDims(dims:Shape):boolean {\n  // check if dims is a permutation of range(dims.length)\n  let prev = -1;\n  for (let i=0; i<dims.length; i++) {\n    const d = dims[i];\n    if (d < 0 || d >= dims.length) {\n      return false;\n    } else if (prev > -1 && d === prev) {\n      return false;\n    }\n    prev = d;\n  }\n  return true;\n}\n\nexport default Tensor;\n"]}