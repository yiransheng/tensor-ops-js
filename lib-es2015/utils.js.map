{"version":3,"file":"utils.js","sourceRoot":"","sources":["../modules/utils.ts"],"names":[],"mappings":"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","sourcesContent":["export interface DeepArray<T> extends Array<T | DeepArray<T>> { }\nexport type Shape = number[];\n\nexport function throwInvariant(condition:boolean, message:string): void {\n  if(!condition) {\n    throw Error(message);\n  }\n}\n\nexport function shapeEqual(...shapes:Shape[]):boolean {\n  if (shapes.length < 2) {\n    return true;\n  }\n  let last = shapes.pop() || [];\n  while (shapes.length) {\n    if (!_shapeEqual(last, shapes.pop() || [])) return false;\n  }\n  return true;\n}\nfunction _shapeEqual(a:Shape, b:Shape) {\n  const checkArray = Array.isArray(a) && Array.isArray(b) && a.length === b.length;\n  if (checkArray) {\n    const len = a.length;\n    for (let i=0; i<len; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nexport function deriveShape<T>(array:DeepArray<T>): Shape {\n  if (!Array.isArray(array)) {\n    return []; // a scalar\n  }\n  const n = array.length;   \n  if (n > 0) {\n    const childShapes = array.map(deriveShape);\n    throwInvariant(shapeEqual(...childShapes), \"Input array is not a tensor\");\n    return [n, ...childShapes[0]] \n  } else {\n    return [0];\n  }\n}\n\nexport function computeStrides(shape: Shape): Shape {\n  const len = shape.length;\n  const strides = new Array(len);\n  let step = 1;\n  for (let i=0; i<len; i++) {\n    strides[len - i - 1] = step;\n    step *= shape[len - i - 1];\n  }\n  return strides;\n}\n\nexport function flattenArray<T>(a: DeepArray<T>):T[] {\n  const output:T[] = [];\n  const queue = [a];\n  while (queue.length) {\n    const array = queue.shift() || [];\n    for (const item of array) {\n      if (Array.isArray(item)) {\n        queue.push(item);\n      } else {\n        output.push(item);\n      }\n    }\n  }\n  return output;\n}\nexport function slice1d<T>(array:T[], start:number, len:number, stride:number): T[] {\n  if (!stride || stride === 1) {\n    return array.slice(start, start + len);\n  } else if (stride > 0) {\n    const output:T[] = [];\n    const end = start + len * stride;\n    for (let i=start; i < end; i += stride) {\n      output.push(array[i]);\n    }\n    return output;\n  }\n  throw Error(\"Invalid Stride for slice1d\");\n}\n\nexport function range(start:number, end:number, step:number=1):number[] {\n  throwInvariant(step > 0 || step < 0, \n      \"(range), step needs to be a number, and cannot be 0\");\n  throwInvariant((end >= start) === (step > 0), \"Infinite loop detected\");\n  const output:number[] = [];\n  const f = step < 0 ? -1 : 1;\n  for (let i=start; (f * i) < (f * end); i+=step) {\n    output.push(i);\n  }\n  return output;\n}\n\nexport function add(a:number, b:number):number {\n  return a + b;\n}\nexport function times(a:number, b:number):number {\n  return a * b;\n}\nexport function sum(nums:number[]):number {\n  return nums.reduce(add, 0);\n}\nexport function product(nums:number[]):number {\n  return nums.reduce(times, 1);\n}\n"]}